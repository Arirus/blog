# Java内存模型与线程

## Java内存模型

### 主内存与工作内存
Java内存模型规定了所有的变量都存储在主内存，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。
![memory_model.png](memory_model.png)

### 内存间交互操作

`lock`,`unlock`,`read`,`load`,`use`,`assign`,`store`,`write` 这8种操作都是原子的，不可再划分的。

### 对于volatile型变量的特殊规则

- 第一项是保证此变量对所有线程的可见性（但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的）
- 第二个语义是禁止指令重排序优化

volatile 的操作是针对的重排序优化是机器级的优化操作，所以字节码看不出来效果的。

### 原子性、可见性与有序性

- 原子性：操作不可分割  synchronized
- 可见性：可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改  
    - final 被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸）
    - synchronized 同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”
    - volatile  
- 有序性： 
    - volatile 关键字本身就包含了禁止指令重排序的语义
    - synchronized 一个变量在同一个时刻只允许一条线程对其进行lock操作，因此持有同一个锁的两个同步块只能串行地进入 

## 线程安全与锁优化

当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。


