---
date : 2018-12-18T23:11:54+08:00
tags : ["Socket", "WebSocket", "网络","HTTPS"]
title : "网络基础 HTTPS Socket WebSocket"

---

上一篇中，我们写了最最常用的网络基础知识，本篇我们要在上篇的基础上再深入的了解些网络知识。

# HTTPS
非单独的协议，是HTTP建立在SSL/TLS上的。
HTTP 可以基于 UDP 实现么？不可以，因为HTTP要求是可靠的传输，因此不能使用 UDP 实现，可以使用别的可靠的传输层协议实现。

HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是供对网站服务器的身份认证，保护交换数据的隐私与完整性。并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的防护。因此使用 HTTPS 主要是为了预防**中间人攻击**和**窃听**。

防止窃听就相对来说简单些，因为 HTTP 是没有加密的，你的所有请求和响应路由器，服务商都知道，因此可能对请求进行窃听甚至篡改（加个广告啥的）。

使用加密就可以解决窃听的问题，因为不是明文传递 HTTP 消息。但是为什么协议加密后，甚至已经对内容使用了非对称加密依然会怕中间人攻击？因为之前我们所说的安全是完全建立在二者的连接已经建立，外界无法获取足够的密钥（公钥或者私钥）来将原文还原出来。但是如果，在连接建立之前就已经被别人顶上了怎么办？例如：A 与 B 打算进行通信，B 首先将 `B公钥` 发送给 A，让 A 进行加密，但此时 `B公钥` 被 C 拦截了，C 把自己的 `C公钥` 发送给了 A，A 不知道这个是假的，依然原路将自己的 `A公钥` 返回给 C。这样 C 就同时获取 `A公钥` 和 `B公钥`。最后 C 把自己的 `C公钥` 冒充 `A公钥` 又传送给 B。这样 A 与 B 都以为自己和对方建立了连接，其实都是和 C 建立连接，C 就既可以冒充 A 也可以冒充 B 来影响对方，这个就是著名的中间人攻击。
这也是为什么第一次使用 SSH 登录服务器的时候，会有一个 Hash 对比的环节，让用户自己确认登录的这个服务器是不我们的目标服务器。

这里的根本原因就是第一次 B 向 A 发送 `B公钥` 时，这个公钥是不可信的，我不知道这个公钥是否是来自与 B。HTTPS 的证书就是为了解决这个问题的。

本质：在客户端和服务器之间协商出一个对称的密钥，每次发送信息之前进行加密，收到之后解密。
连接：（整个步骤都是 TCP 的）

    1 客户端请求建立 TLS 连接 （发送：TLS版本, 对称加密算法， 非对称加密算法， Hash算法，客户端随机数）
    2 服务端说好的 （返回：TLS版本, 对称加密算法， 非对称加密算法， Hash算法，客户端随机数，服务器随机数）
    3 服务器发回证书 (其实包含是服务器的公钥)
    4 客户端验证服务器证书 （证书包含：服务器域名，证书公钥，证书签名（用来证明证书的公钥是被证书机构所签发的，这里面还包括证书机构的公钥，证书机构的其他信息））（如果请求域名和证书里的服务器域名不一致，也是会警告的）
    5 客户端信任服务端之后，与服务器协商对称加密 （使用服务器公钥非对称加密 Pre-Master Secret，传给服务器）
    6 生成 Master Secret（非密钥，两端分别是使用 Pre-Master Secret，客户端随机数，服务端随机数生成，不传输）
    7 生成 客户端加密密钥，服务端加密密钥，客户端 Mac Secret，服务端 Mac Secret （两端分别生成，不传输）（其中加密密钥是**加密**原文的，Mac Secret用来构造Hash用来**验证**身份）
    8 客户端验证加密通信，发送之前的所有信息通过加密签名发过去
    9 服务器验证加密通信，发送之前的所有信息通过加密签名发过去
    10 开始正常发送消息 应用层消息：%SGDIGSIDS……%*&


为什么有了HTTPS还有使用 Authorzation Bearer？HTTPS 是保证不被中间人攻击，后者是给第三方授权使用，不是一个频道的。

最后一个，就算使用了HTTPS协议，里面的关键数据也不要用明文的？

为了说明上面一个问题，我们使用 Charles 代理来看看。

## Charles 代理
结合上面的 HTTPS 的知识，我们结合 Charles 抓包来看一下。本次代理使用的 Charles 版本为 4.2.7 正式版，所有代理均是通过 WEB 端来完成，没有使用移动端进行测试。

### HTTP 代理
首先是 HTTP 代理测试，这里我们选取 [http://httpbin.org/](http://httpbin.org/) 这个网站进行测试。正常使用 Charles 抓包，可以得到如下的效果

![httpbin 代理](/img/http_overview.PNG)

因为没有使用 HTTPS，图中TLS数据全部都是为空。接下来我们看下HTTP传输内容：

![httpbin 代理](/img/http_contents.PNG)

一个标准的 HTTP 的请求，与响应，我们从中可以获取我们想要的所有内容。注意，如果对 HTTP 的 API 进行加密的话，最多就是加密 requestBody、responseBody ，部分的 Headers ，就是对传输数据内容的加密，而非整个 HTTP 的加密，因此安全性来说，依然是存在的。

### HTTPS 代理
配置好 Charles 的 CA 证书，我们就可以开始进行 HTTPS 代理了。不过在开始之前，我们先看下正常情况下使用 HTTPS 请求的 CA 证书。

![正常的证书](/img/phub_ca.PNG)

例如，当我们在浏览器中访问 P站 时，地址栏左侧会出现一个小锁的标识，点击进去可以看到证书的相关信息，包括根 CA 、使用者信息、指纹、签名算法等等，这个证书的根 CA 是 DigiCert，这个证书是存在电脑系统中的，因此我们认为是可信的（毕竟 CNNIC 用了都说好~~）。

好了，我们先来看下在没有开启 SSL 配置时，Charles 对于 HTTPS 的解析情况。也就是完全模拟一个观察者，就像网络供应商，各个路由器的角色一样，这里我们以访问[知乎](https://www.zhihu.com)为例：

![知乎 代理](/img/https_overview.PNG)

解析情况入上图，我们知道在HTTPS开始传输数据之前TLS/SSL 建立时，客户端服务端是走的明文传输，这里我们也截获了诸如 TLS 版本，客户端支持的加密算法，服务器选择的加密算法等信息。我们再看其传输的具体内容：

![知乎 代理](/img/https_contents.PNG)

Charles 无法解析，无论是发送的请求还是返回的响应都是无法显示。其显示的头部应该是 Charless 自己推断出来的，非真正解析，因为不符合标准 HTTP 请求头响应头格式（只是猜测）。也就是说对于另一个窃听者，他看到的也应该是一样的一个东西，无法解密。好了，我们开启 SSL 配置，再次尝试访问知乎，会发现抛出以下错误：

![中间人攻击](/img/https_proxy.PNG?)

同时地址栏左侧变为显示不安全：

![证书不匹配](/img/charles_ca.PNG)

我们发现，现在由于 Charles 作为中间人来代理访问，对于 Chrome 客户端来说，服务器的证书发生了变化，因此可以视为发生了`中间人攻击`，因此拒绝我们继续访问知乎。那这里我们换另一个之前没有建立的HTTPS网站，进行测试，以[苏宁](https://www.suning.com)为例，并且在Chrome弹出证书信任页面时要进行`信任`，最后在 Charles 中进行观察:

![Charles 代理 HTTPS](/img/https_proxy_overview.PNG)

不同于未开启 SSL 时的访问，请求的 Meathod，Content-Type 都是可以获取的。再对比下请求响应信息：

![Charles 代理 HTTPS](/img/https_proxy_contentes.PNG)

请求响应信息一应俱全，就像是没有使用HTTPS加密一样。

### 结论
那么我们先来说下问题的答案，使用了 HTTPS ，里面的数据还要不要使用明文传输？如果不想让用户自己能分析数据（抓包）, 还是要继续加密, 这样增加了破解的难度, 需要反编译 app 拿到加密密钥才能解密。如果只是不想让用户以外的第三方拿到数据, 那么用 HTTPS 足以, 防范中间人攻击即可, 也分两种情况：用的是 CA 签发的证书, 用系统接口发起 HTTPS 链接就会校验证书合法性了(这样是不是能完全避免中间攻击? 不一定, 如果有人能用CA签发**同域名证书**那么还是能进行的)用的是自签名证书, 就要手动对服务器证书进行合法性校验了。
最后，我们给出使用 HTTPS 的结论：

    1.使用 HTTPS 可以有效的`预防``中间人攻击`和`窃听`，其中证书用于验证服务端身份避免中间人攻击，加密避免被窃听；
    2.使用 HTTPS 时，如果不是用加密数据作为 Header 或 Body 传输，则同样有数据被泄漏的风险。

# Socket
其实 Socket 这个概念是非常宽泛的一个概念，不是仅仅针对于网络连接的。我们在[跨进程通信 Binder AIDL](https://arirus.cn/post/android-%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-binder-aidl-/)里面就提到过 Socket 是用于 Linux 的跨进程通信的重要方式。其实 Socket 就是操作系统的提供的一套进程间通信机制，Socket 长分为两类：第一，Unix domain socket 可以使同一台操作系统上的两个或多个进程进行数据通信，不在本篇的讨论内容。
第二，Network socket 网络连接上使用的，基于 TCP 或者 UDP 的通讯接口，这个是本篇讨论的重点内容。

HTTP 通信使用的是“请求-响应模式”，这也就是注定了请求和响应是一一对应的，只有客户端对服务器发出了请求，才会收到服务器的响应，服务器是无法做到主动对客户端进行通信的，而且 HTTP 是存在短连接的情况了，进行完一次 HTTP 请求就会断开连接。这也就是对于 IM 功能，普通的 HTTP 是没有很好应对的。

## HTTP 长连接
HTTP 长连接是1.1之后的版本比较常用的一种模式（所谓持久化），举个例子，现在网站非常大，除了 html 外还有很多 js css 文件，如果每次请求都是重新打开 HTTP 连接，那么开销会非常大，效率会非常低。使用 HTTP 的长连接，在一次连接的过程中可将这些所有的文件都传输过去。网上有个挺著名的图可以说清楚这点。

![HTTP 长连接](https://lc-api-gold-cdn.xitu.io/fd0ebc99255c696b9841)

那么是不是说可以使用 HTTP 长连接来做 IM 功能，其实也不好。因为本质上没有变化，还是“请求-响应模式”，不过是减少了连接的握手次数，依然要一个发起请求一个响应请求。这种模式下如果要做 IM 功能，那就要使用 **轮询** 技术，客户端每隔一定时间向服务器请求查询，返回有没有新的数据。

所以从本质上来说，**HTTP 协议是不适合用作 IM 功能**，这是协议的性质决定的，不是修改某些技术细节可以改变的。

## TCP 长连接
TCP 长连接是一种保持 TCP 连接的机制。当一个 TCP 连接建立之后，启用 TCP Keep Alive 的一端便会启动一个计时器，当这个计时器到达 0 之后，一个 TCP 探测包便会被发出。这个 TCP 探测包是一个纯 ACK 包，但是其 Seq 与上一个包是重复的。

## Socket 与 HTTP
Socket 与 HTTP 的最大区别就是两个没有比较的意义。为什么这么说呢，HTTP 是一个应用层的传输协议，一个正式协议，文档[rfc2616](https://tools.ietf.org/html/rfc2616)中没说一定要是基于 TCP 实现的，只是说其本身是一个可靠的协议，也就是说可以用别的协议实现，不过通常都是基于 TCP 来实现的。Socket 不是协议而是应用层与传输层之间的同一个抽象层，它是一套接口，所以 Socket 连接可以基于 TCP 连接，也有可能基于 UDP 。Socket 没有协议格式等等文档上的规范，更多的是接口上规范。二者维持长连接可能都需要发送心跳包来维持连接的保持。最关键的是 Socket 不是“请求-响应模式”，通信的双方都可以给直接对方发送数据。所以简单的一句话来描述：

**Socket 是对于控制 TCP/UDP 传输而抽象出来的接口，是个 API，HTTP 是实实在在的应用层协议，基本上是基于 TCP 来实现的。Socket 允许双方主动通信，HTTP 只允许客户端请求服务端**

# WebSocket
WebSocket 是一种在单个TCP连接上进行全双工通信的协议。它也是一个应用层的协议，功能上十分类似 Socket，即允许长连接和双端同时发送数据。其具有以下特点：

- 建立在 TCP 协议之上，服务器端的实现比较容易。
- 数据格式比较轻量，性能开销小，通信高效。
- 可以发送文本，也可以发送二进制数据。
- 没有同源限制，客户端可以与任意服务器通信。

这里借用阮老师的图片对比下与 HTTP 连接的不同：

![websocket](/img/websocket.png) 可以看到其本身还是使用了 HTTP 的请求。中间当 WebSocket 连接建立之后，双端通信均不需要再发送 HTTP 协议，而是发送 frame 这里我们就不展示，我们只是简单说明一下其概念，有兴趣的可以通过 Chrome 来观察一下。有一点需要注意的是 WebSocket 本身全双工的，即可以同时收发消息，但是 HTTP 碍于其响应机制其本身是半双工的，不能同时收发。

## Android 使用
Android 上如果需要 Socket，建议直接使用 WebSocket 协议来进行连接，OkHttp 是实现了 WebSocket 的请求。不过个人感觉使用起来并不舒服，他还是以 HTTP 的思路来考虑 WebSocket ，一个 Url 来对应一次 WebSocket 的连接。HTTP 这样做无可厚非，因为每次的请求对应的 Url 都不一致，但是对于 WebSocket 通常是建立一次连接，就开始两端相互发送数据，这里面不在涉及到新的 HTTP 请求。同时，可能需要心跳保活等等操作，全部放在一个 Client 中进行监听，逻辑上并不好看。

我个人在项目使用的是 [Socket-io-Java](https://github.com/socketio/socket.io-client-java) 里面 Socket 的逻辑更符合正常的使用的逻辑，更为友好。

# 小结
本篇的内容更为理论一些，不过如果知道了这些理论对于实践会很有帮助，目前网络基础打算就是这么多，如果又想到了再补充。