---
date : 2018-10-16T21:01:54+08:00
tags : ["TCP/IP", "网络","HTTPS"]
title : "网络基础 TCP/IP HTTP"

---

# 写在最前面
作为一个合格的程序员，基础的网络知识是必不可少的，无论是否从事网络开发。在知识体系下，没有什么是孤岛，需要做的就是把各个知识都连接起来，本篇我们就来回顾下网络的基础知识。

# TCP / IP 协议族 
互联网协议是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。它常被通称为TCP/IP协议族简称TCP/IP。因为该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。TCP/IP提供点对点的链接机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。

TCP/IP参考模型是一个抽象的分层模型，这个模型中，所有的TCP/IP系列网络协议都被归类到4个抽象的"层"中。每一抽象层创建在低一层提供的服务上，并且为高一层提供服务。 完成一些特定的任务需要众多的协议协同工作，这些协议分布在参考模型的不同层中的，因此有时称它们为一个协议栈。

四层主要作用：

    应用层：该层包括所有和应用程序协同工作，利用基础网络交换应用程序专用的数据的协议。
    传输层：能够解决诸如端到端可靠性（“数据是否已经到达目的地？”）和保证数据按照正确的顺序到达这样的问题。
    网络层：解决在一个单一网络上传输数据包的问题。
    链路层：它是数据包从一个设备的网络层传输到另外一个设备的网络层的方法。

分层的目的在于更为有效的传输数据，例如如果要传输的一个大块儿数据在网络上传输，但是网络本身就是不稳定的，你不知道哪个路由是好的，哪个是坏的，如果一大块儿数据被传到坏的路由器，那么只能整体重新传输，效率十分底下，如果使用了tcp的分割，哪儿部分没有传递成功，我们只需要传递失败的部分，会大大提高传输效率。

这四层分别是：应用层（HTTP FTP DNS VoIP SSH IMAP SMTP TLS/SSL 等）传输层（TCP UDP）网络层（IP ICMP）
链路层（以太网 ARP）。我们来调几个重要的记录一下。

## IP （Internet Protocol）
IP 是非面向连接（通信前不需要建立连接，不可靠的）IP协议的独特之处在于：在报文交换网络中主机在传输数据之前，无须与先前未曾通信过的目的主机预先创建好一条特定的“通路”。它不保证数据能准确的传输，只能尽力的传输。如果应用需要保证可靠性，一般需要采取其他的方法，例如利用IP的上层协议控制。

IPv4使用地址解析协议（ARP），而IPv6采用邻居发现协议（NDP）。来将数据发送出去。

## TCP （Transmission Control Protocol）
TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议。应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分割成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。
TCP协议的运行可划分为三个阶段：连接创建(connection establishment)、数据传送（data transfer）和连接终止（connection termination）。

**通信双方建立确认「可以通信」，不会将对方的消息丢弃，即为「建立连接」**

创建阶段是三路握手（Three way Handshake）：
    
    客户端说：我要发起会话了，你准备好了么？（SYN）；
    服务器说：好的我知道了（ACK），我也要发起会话了，你准备好了么？（SYN）
    客户端说：好的我知道了（ACK）
如果服务器端接到了客户端发的SYN后回了SYN-ACK后客户端掉线了，服务器端没有收到客户端回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，服务器端如果在一定时间内没有收到的TCP会重发SYN-ACK。这也是为什么要是有三次握手来建立通信，**避免因网络延迟的原因，使得服务器收到一个过期的开始连接的请求，从而造成资源浪费甚至死锁**

在TCP的数据传送状态，很多重要的机制保证了TCP的可靠性和强壮性。它们包括：使用序号，对收到的TCP报文段进行排序以及检测重复的数据（序号和确认号结合）；使用校验和检测报文段的错误，即无错传输（16位校验和）；使用确认和计时器来检测和纠正丢包或延时；流控制（Flow control）；拥塞控制（Congestion control）；丢失包的重传。

连接终止是四路握手（Four way Handshake）：

    客户端说：我要结束连接了（FIN）；
    服务器说：好的我知道了（ACK）
    服务器说：我要结束连接了（FIN） // 此时不是一起发送的，因为可能还有数据在发
    客户端说：好的我知道了（ACK）

## UDP（User Datagram Protocol）
UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。由于缺乏可靠性且属于非连接导向协议，UDP应用一般必须允许一定量的丢包、出错和复制粘贴。因此 UDP 的每个数据包是没有编号的，UDP通过16位源端口号和16位目的端口号来实现应用程序间的区分。16位UDP校验和可以实现传输层的校验，虽然UDP协议不具备纠错能力，但是可以对出错的数据包进行丢弃。

为什么不能用 IP 代替 UDP：因为ip关心的是逐跳转发的选路细节，ip的不可靠指的不是某种服务，而是尽力而为传输ip数据包。tcp和udp为上层提供端到端的连接并开启相应端口，不关心选路细节。两者功能都不一样，当然不能用ip代替udp。可以把IP协议当作盒子，里面存放 TCP 或者 UDP 等不同的报文，具体里面的数据对应的哪个部分由报文决定。IP只是给你传过来了，侧面的说 UDP 的不可靠性就是 IP 的不可靠性引起的，如果 IP 可靠了，UDP 就可靠了。
tips：

    TCP (Transport layer 传输层)        ==> message[报文]    Segment  [报文分组]
    IP (Network layer 网际层)              ==> Datagram  [数据报 or 数据包]，抓包就是在这一层抓Ethernet (Link layer  链路层)         ==> Frame  [帧]
    物理层    ==> Bit  [比特]

# HTTP
不同于 TCP 协议和 IP 协议，我们几乎不会在编写应用的时候直接使用 TCP IP，我们更为常用的是 HTTP 协议。下面我们就来说说 HTTP 的相关内容。
## 协议格式
HTTP 协议分为请求报文和响应报文，请求报文格式为：
```java
GET /path HTTP/1.1
Host: www.google.com
Content-Type: text/plain

boooooooooooooooooody
```
第一行分别是 方法 路径 HTTP 版本。这一行的内容是一定要传输的，必选的。
第二行之后是 Header 部分，可以理解成属性相关的内容，非必选的。
最后部分是请求体部分，对于 POST 方法等来说是必传的。

服务器的响应报文格式为：
```java
HTTP/1.1 200 OK
Content-Length: 3059
Server: GWS/2.0
Date: Sat, 11 Jan 2003 02:44:04 GMT
Content-Type: text/html
Cache-control: private
Set-Cookie: PREF=ID=73d4aef52e57bae9:TM=1042253044:LM=1042253044:S=SMCc_HRPCQiqy
X9j; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com
Connection: keep-alive

boooooooooooooooody
```
第一行分别是 HTTP 版本 状态码 和消息。这一行也是必传的。
第二行往后是响应的 Header
最后部分就是响应体部分，通常所有的响应都会有。

## 请求方法
请求方法可以参看[Retrofit源码 流程篇](https://arirus.cn/post/retrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97-%E6%B5%81%E7%A8%8B%E7%AF%87/) 中有对多所有方法的举例，这里我们只说4个最常用的：

- GET 无副作用，幂等，不可带 Request Body
- POST 副作用，非幂等，可以带 Request Body
- PUT 副作用，幂等，可以带 Request Body
- DELETE 副作用，幂等，不可带 Request Body

这里有两个概念：**副作用**，**幂等**，副作用是对服务器产生的影响，幂等是多次操作造成的结果是否相同。GET 方法这样看无疑是最"安全"的方法，无论多少次操作都不会改变什么。但是 POST 和 PUT 两个是最容易让人混淆的，从使用者的角度二者没任何区别，但是从语义上来说，二者有很大的不同，如果有个 API 是上传文件到文件仓库，并不会把我上一次上传的文件给覆盖掉，那么我使用 POST 来描述这个 API 更合适，但是同样是上传文件，我想上传一个新的用户头像，就会把我之前的头像给完全替换掉，这样 API 应该被设计为 PUT 方法。这就是所谓的幂等，可以多次应用而不会改变初始应用之外的结果。

## 状态码
状态码用于描述 API 请求结果的情况，第一个数字代表当前响应的类型：

- 1xx：临时性消息。如：100 （继续发送）、101（正在切换协议）
- 2xx：成功。最典型的是 200（OK）、201（创建成功）。
- 3xx：重定向。如 301（永久移动）、302（暂时移动）、304（内容未改变）。
- 4xx：客户端错误。如 400（客户端请求错误）、401（认证失败）、403（被禁⽌）、404（找不到内容）。
- 5xx：服务器错误。如 500（服务器内部错误）。

## HTTP 中授权的两种方式
都是利用HTTP request header来传递身份信息。
都需要后台给予验证身份的唯一ID（也可理解为唯一的验证信息）
### Cookies
工作机制：

    服务器需要客户端保存的内容，放在 Set-Cookie headers 里返回，客户端会自动保存。
    客户端保存的 Cookies，会在之后的所有请求里都携带进 Cookie header 里发回给服务器。
    客户端保存 Cookie 是按照服务器域名来分类的，例例如 shop.com 发回的 Cookie 保存下来以后，在之后向 games.com 的请求中并不会携带。
    客户端保存的 Cookie 在超时后会被删除、没有设置超时时间的 Cookie （称作 Session Cookie）在浏览器关闭后就会⾃自动删除；另外，服务器也可以主动删除还未过期的客户端 Cookies。

使用 Cookies 来保持登录，就是使用通过服务端设置一个 session id 在 Cookie 中，每次客户端访问时将 session id 传给服务器来验证身份。本质上就是客户端拿着自己的 token 来进行验证。不过这个 Cookies 是由HTTP客户端自动添加到下一次的请求中，因此有可能被 js 获取。同时需要注意的是：session id 是会在服务端被存储了，每次新的请求会对比 session id ，用来确定用户信息，在这个层面来说 Cookies 是有状态的。

### Authorization
Authorization 传输的 token 是无状态的（stateless）。也就是说，服务端不需要在数据库中存储和Token相关的字段，Token本身就已经包含了用户的所有信息。Token 可以由服务端返回的，也可以自己产生（Basic 方式就是由客户端自己来产生的，服务端只是获取信息），但是不会自己设定到 Header 上，需要用户手动将其设置到 Header 上。Authorization 分为两类 Basic 和 Bearer。

#### Basic
基本认证方式，其格式为：
    Authorization: Basic <username:password(Base64ed)>。
编码这一步骤的目的并不是安全与隐私，而是为将用户名和口令中的不兼容的字符转换为均与HTTP协议兼容的字符集。
因此如果仅仅是在HTTP协议上，使用 Authorization: Basic 和 Cookies 都是不够安全的。**Authorization: Basic 仅仅做身份信息的验证，没有任何的加密性在里面**，其安全性的保证是建立在 TLS/SSL 层面的。

#### Bearer
除了 Basic 方式，还支持使用 bearer 令牌通过OAuth 2.0保护资源。这种认证方式通常用于第三方授权。这里第一方是“我们”即用户，第二方是“资源提供者”（Google Photos等），第三方是“资源使用者”（各种 App）。 其格式为：
    
    Authorization: Bearer <bearer token>
传统的 Client-Server 模式在第三方授权时，有如下缺点：密码等信息会被第三方保存，这时候是相当与没有“权限”的概念的，相当于这个第三方应用就是你，可能会导致密码泄漏，同时也不方便撤销权限。

因此使用 OAuth 2.0 来保护资源是非常重要的。其流程是如下：
```java
+--------+                               +---------------+
|        |--(A)- Authorization Request ->|   Resource    |
|        |                               |     Owner     |
|        |<-(B)-- Authorization Grant ---|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(C)-- Authorization Grant -->| Authorization |
| Client |                               |     Server    |
|        |<-(D)----- Access Token -------|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(E)----- Access Token ------>|    Resource   |
|        |                               |     Server    |
|        |<-(F)--- Protected Resource ---|               |
+--------+                               +---------------+
```
这里 Client 就是第三方各种应用。Resource Owner 第一方通常是我们自己，拥有资源的所有权。Resource Server 第二方，保管我们的各种资源。Authorization Server 没有明确的指认，通常是可以和第二方沟通的，可以任务也是第二方，用来发放token认证。

流程是这样的：

    （A）用户打开客户端以后，客户端要求用户给予授权。

    （B）用户同意给予客户端授权。

    （C）客户端使用上一步获得的授权，向认证服务器申请令牌。

    （D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。

    （E）客户端使用令牌，向资源服务器申请获取资源。

    （F）资源服务器确认令牌无误，同意向客户端开放资源。

注意，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。其中`授权码模式`是最严密的，功能最完整的模式。它的特点就是通过客户端的后台服务器，与"服务提供商"的认证服务器进行互动。而第三方应用的客户端不直接与认证服务器进行交流。区别在于客户端要求到了客户的授权，得到一个授权码，通过第三方的后台服务器与认证服务器建立连接，根据授权码获取相应的 token，最后将 token 返回到第三方的服务器，使用后可以向 Resource Server 请求资源。

![授权码模式](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051204.png)

这种做法是相信第三方的服务器，同时也尽量避免直接把 token 共享给第三方客户端使用，有取资源的操作尽量在第三方的服务器上完成。都是为了安全。

自家的 App 会在 Api 的设计中，将登录和授权设计成类似 OAuth2 的过程，但简化掉
Authorization code 概念。即：登录接⼝口请求成功时，会返回 access token，然后客户端在之
后的请求中，就可以使⽤用这个 access token 来当做 bearer token 进⾏行行⽤用户操作了了。

Refresh Token 可以向 Authorization Server 重新取得一個新的 Access Token，同时会使得现有的 Access Token 失效。
```java
+--------+                                           +---------------+
|        |--(A)------- Authorization Grant --------->|               |
|        |                                           |               |
|        |<-(B)----------- Access Token -------------|               |
|        |               & Refresh Token             |               |
|        |                                           |               |
|        |                            +----------+   |               |
|        |--(C)---- Access Token ---->|          |   |               |
|        |                            |          |   |               |
|        |<-(D)- Protected Resource --| Resource |   | Authorization |
| Client |                            |  Server  |   |     Server    |
|        |--(E)---- Access Token ---->|          |   |               |
|        |                            |          |   |               |
|        |<-(F)- Invalid Token Error -|          |   |               |
|        |                            +----------+   |               |
|        |                                           |               |
|        |--(G)----------- Refresh Token ----------->|               |
|        |                                           |               |
|        |<-(H)----------- Access Token -------------|               |
+--------+           & Optional Refresh Token        +---------------+

```
用法：access token 有失效时间，在它失效后，调用 refresh token 接口，传入 refresh_token
来获取新的 access token。由于（在标准的 OAuth2 流程中）refresh token 永远只存在与第三方服务的服务
器中(不会暴露给第三方客户端)，因此 refresh token 几乎没有失窃的风险。

# 小结
本篇中，我们尝试先站在最高处，来了解 TCP/IP 协议整体分层情况，接着简要的了解了 IP TCP UDP 的一些基本概念，最后详细的介绍了 HTTP 协议相关的内容。那么本篇的内容就到此结束，我们下篇再见。
