## 用栈组成队列
https://leetcode.cn/problems/implement-queue-using-stacks/

```java
class MyQueue {

     
    Stack<Integer> s1 = new Stack();
    Stack<Integer> s2 = new Stack();

    public MyQueue() {

    }
    
    public void push(int x) {
        s1.push(x);
    }
    
    public int pop() {
        // pop 的时候如果s2里面非空 优先s2的内容
        if(!s2.isEmpty()) return s2.pop();
        while(!s1.isEmpty()){
            s2.push(s1.pop());
        }
        return s2.pop();
    }
    
    public int peek() {
        // peek 的时候如果s2里面非空 优先s2的内容
        if(!s2.isEmpty()) return s2.peek();
        while(!s1.isEmpty()){
            s2.push(s1.pop());
        }
        return s2.peek();
    }
    
    public boolean empty() {
        return s1.isEmpty() && s2.isEmpty();
    }
}
```

## 用队列组成栈
https://leetcode.cn/problems/implement-stack-using-queues/description/

```java
class MyStack {

public    Queue<Integer> q1 = new ArrayDeque();
public    Queue<Integer> q2 = new ArrayDeque();

    private void sweap(){
        Object tmp = q1;
        q1 = q2;
        q2 = (Queue<Integer>)tmp;
    }

    public MyStack() {

    }
    
    public void push(int x) {
        q1.add(x);
    }
    
    public int pop() {
        while(!q1.isEmpty()){
            int val = q1.poll();
            if(q1.isEmpty()) {
                sweap();
                return val;
            }
            q2.add(val);
        }
        return 0;
    }
    
    public int top() {
        while(!q1.isEmpty()){
            int val = q1.poll();
            q2.add(val);
            if(q1.isEmpty()) {
                sweap();
                return val;
            }
        }
        return 0;
    }
    
    public boolean empty() {
        return q1.isEmpty()&&q2.isEmpty();
    }
}
```

以上这两个实现可以考虑在push做相关操作，更方便些

## 匹配括号
https://leetcode.cn/problems/valid-parentheses/
```java
public boolean isValid(String s) {
    Stack<Character> stack = new Stack();

    for(int i=0;i<s.length()-1;i++){
        char c1 = s.getCharAt(i);
        if(left(c1)){
            stack.push(c1);
        }else{
            // 当第一个元素为右括号 那么肯定是非对称
            if(stack.isEmpty()) return false;
            char c2 = stack.pop();
            if(!pair(c1,c2)) return false;
        }

    }

    // 当stack里遗留元素 认为是非对称的
    return stack.isEmpty();


}

public boolean left(char c){
    return c=='(' || c=='{' || c=='[' ;
}

public boolean pair(char c1, char c2){
    return (c1=='(' && c2==')')||
            (c1=='{' && c2=='}')||
            (c1=='[' && c2==']');
}


// 有种小优化方案，当判断到是左括号时，将右括号入栈，当右括号入栈时 判断站顶元素啊是否相同即可，最后判断是否为空
public boolean isValid(String s) {
    Stack<Character> stack = new Stack();
    for(int i = 0 ; i<s.length(); i++){
        char c = s.chatAt(i);
        if(c=='(')stack.push(')');
        else if(c=='{')stack.push('}');
        else if(c=='[')stack.push(']');
        else if(stack.isEmpty() || stack.peek()!=c) return false;
        else stack.pop();
    }

    return stack.isEmpty();

}
```

## 逆波兰表达式求
https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/

```java
public int evalRPN(String[] tokens) {
    // 这里可以考虑使用 Stack<Integer> 这样仅仅每次读区token时进行转换即可。
    Stack<String> stack = new Stack();
    for(int i = 0 ; i< tokens.length; i++){
        String cur = tokens[i];
        if(symbol(cur)){
            int s1= Integer.valueOf(stack.pop());
            int s2= Integer.valueOf(stack.pop());
            int result = 0;
            if(cur.equals("+")) result = s1+s2;
            // 因为stack 出入的顺序是反的，因此计算的顺序也要是发的
            else if(cur.equals("-")) result = s2-s1;
            else if(cur.equals("*")) result = s1*s2;
            // 因为stack 出入的顺序是反的，因此计算的顺序也要是发的
            else if(cur.equals("/")) result = s2/s1;
            stack.push(String.valueOf(result));
        }
        else stack.push(cur);
    }
    return Integer.valueOf(stack.pop());
}

public boolean symbol(String s){
    return s.equals("+") || s.equals("-") || s.equals("*") ||s.equals("/");
}
```

## 滑动窗□最大值

https://leetcode.cn/problems/sliding-window-maximum/
```java
public int[] maxSlidingWindow(int[] nums, int k) {
    int result = new int[nums.length-k+1];
    //维护成为一个单调队列,这个队列只需要两个元素；
    Deque<Integer> deque = new LinkedList<>();
    int[] res = new int[nums.length - k + 1];
    for(int right = 0, left = 1 - k; right < nums.length; left++, right++) {
        // 删除 deque 中对应的 nums[i-1]
        if( left > 0 && deque.peekFirst() == nums[left - 1])
            deque.removeFirst();
        // 保持 deque 递减
        while(!deque.isEmpty() && deque.peekLast() < nums[right])
            deque.removeLast();
        deque.addLast(nums[right]);
        // 记录窗口最大值
        if(left >= 0)
            res[left] = deque.peekFirst();
    }
    return res;

}
```
## 前K个高频元素

https://leetcode.cn/problems/top-k-frequent-elements/description/
```java
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer,Integer> map = new HashMap();
    PriorityQueue<int[]> queue = new PriorityQueue(new Comparator<int[]>{
        int public compare(int[] p1,int[] p2){
            return p1[1]-p2[1];
        }
    });

    int[] result = new int[k];

    // 通过map 存储对应频率
    for(int num:nums){
        if(map.get(num)!=null){
            map.put(num,1);
        }else{
            map.put(num,map.get(num)+1);
        }
    }

    for(int key:map.keys()){
        // 可以对存储读区逻辑进行优化
        // queue.add(new int[]{key,map.get(key)});
        // if（queue.size() > k） queue.pop();
        if(queue.size() == k){
            if(queue.peek().value<map.get(key)){
                queue.poll();
                queue.add(new int[]{key,map.get(key)});
            }
        }else{
            queue.add(new int[]{key,map.get(key)});
        }
    }

    for(int index:k){
        result[index] = queue.pop().key;
    }
    return result;
}
O(nlogk) O(n)
```

## 接雨水
https://leetcode.cn/problems/trapping-rain-water/

```java
//使用单调栈
public int trap(int[] height) {
    if(height == null) return 0;
    // 单调栈 用来存储数组的索引。我们存放的是递减单调。
    Stack<Integer> stack = new Stack();
    int sum = 0;

    for(int i = 0; i<height.length; i++){
        //当单调栈非空的时候，我们判断如果新数据大于栈顶数据，此时是会形成水池
        while(!stack.isEmpty() && height[stack.peek()] <height[i]){
            //此时站顶的高度就是水池的底部。接下来要确定水池左右以及高度就可以了。
            int cur = stack.pop();
            //将和水池底高度一样的索引移除，这些都是底部
            while(!stack.isEmpty() && height[stack.peek()]==height[cur]){
                stack.pop();
            }
            //此时可以确定水池左侧和水池右侧
            if(!stack.isEmpty()){
                int left = stack.peek();
                int right = i;
                //水池高度一定是左右侧的最小值减去水池底部，然后再乘以长度
                sum += (Math.min(height[right],height[left]) - height[cur])*(right-left+1);
            }
        }
        //计算完之后 将水池右侧入栈形成新的水池左侧
        stack.push(i);
    }
    return sum;
}
```
