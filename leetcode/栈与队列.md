## 用栈组成队列
https://leetcode.cn/problems/implement-queue-using-stacks/

```java
class MyQueue {

     
    Stack<Integer> s1 = new Stack();
    Stack<Integer> s2 = new Stack();

    public MyQueue() {

    }
    
    public void push(int x) {
        s1.push(x);
    }
    
    public int pop() {
        // pop 的时候如果s2里面非空 优先s2的内容
        if(!s2.isEmpty()) return s2.pop();
        while(!s1.isEmpty()){
            s2.push(s1.pop());
        }
        return s2.pop();
    }
    
    public int peek() {
        // peek 的时候如果s2里面非空 优先s2的内容
        if(!s2.isEmpty()) return s2.peek();
        while(!s1.isEmpty()){
            s2.push(s1.pop());
        }
        return s2.peek();
    }
    
    public boolean empty() {
        return s1.isEmpty() && s2.isEmpty();
    }
}
```

## 用队列组成栈
https://leetcode.cn/problems/implement-stack-using-queues/description/

```java
class MyStack {

public    Queue<Integer> q1 = new ArrayDeque();
public    Queue<Integer> q2 = new ArrayDeque();

    private void sweap(){
        Object tmp = q1;
        q1 = q2;
        q2 = (Queue<Integer>)tmp;
    }

    public MyStack() {

    }
    
    public void push(int x) {
        q1.add(x);
    }
    
    public int pop() {
        while(!q1.isEmpty()){
            int val = q1.poll();
            if(q1.isEmpty()) {
                sweap();
                return val;
            }
            q2.add(val);
        }
        return 0;
    }
    
    public int top() {
        while(!q1.isEmpty()){
            int val = q1.poll();
            q2.add(val);
            if(q1.isEmpty()) {
                sweap();
                return val;
            }
        }
        return 0;
    }
    
    public boolean empty() {
        return q1.isEmpty()&&q2.isEmpty();
    }
}
```

以上这两个实现可以考虑在push做相关操作，更方便些
