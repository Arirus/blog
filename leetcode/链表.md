## 1 反转链表 
https://leetcode.cn/problems/reverse-linked-list/description/

```java
class Node(){
    int value;
    Node next;
}
// 递归
Node reverse(Node head){
    if(head == null ||head.next == null)return head

    Node rest = reverse(head.next);
    head.next.next = head
    head.next =null;

   return rest;
}

1->2->3
1->2<-3
1<-2<-3
// 时间O(n) 空间O(n)

//双指针
Node reverse(Node head){
    if(head == null ||head.next == null)return head;

    Node pre = null;
    Node cur = head;
    Node next = null;

    while(cur!=null){
        //设置下一个node
        next = cur.next;
        //将当前的下一个设为之前的
        cur.next = pre;
        //前一个为当前的
        pre = cur;
        //当前的为后一个
        cur = next;
    }
    return pre;

}
时间O(n) 空间O(1)

```

## 2 合并两个有序链表
https://leetcode.cn/problems/merge-two-sorted-lists/description/
```java
//合并两个有序链表
//https://leetcode.cn/problems/merge-two-sorted-lists/description/
Node merge(Node list1,Node list2){
    //虚头部
    Node dummy = new Node(-1);
    Node cur = dummy
    Node p1 = list1;
    Node p2 = list2;

    while(p1!=null&&p2!=null){
        if(p1.val<p2.val){
            cur.next = p1;
            p1 = p1.next;
        }else{
            cur.next=p2;
            p2 = p2.next;
        }
        cur = cur.next;
    }

    if(p1!=null) cur.next = p1;
    if(p2!=null) cur.next = p2;

    return dummy.next;
}

时间复杂度：O(m+n) 空间复杂度：O(1)


Node merge(Node list1, Node list2){
    Node result = null;

    if(list1==null) return list2
    if(list2 == null) return list1


    if(list1.val<list2.val){
        result = list1
        result.next = merge(list1.next,list2)
    }else{
        result = list2
        result.next = merge(list1,list2.next)
    }
    return result
}
时间复杂度：O(m+n) 空间复杂度：O(m+n)

```

## 3 删除排序链表中的重复元素
https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/

```java
//删除排序链表中的重复元素
//https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/
Node filter(Node list){
    if(list == null) return list;
    Node cur = list;
    Node next = cur.next;
    
    while(next!=null){
        //逆向思路：如果不等的时候 cur 是往前进的
        // 同时要保持链不断
        if(cur.val != next.val){
           cur.next = next;
            cur = cur.next;
        }

        //还可以这么写：不等时候 cur 向前进，相等的时候 修改cur的next指向
        // if(cur.val != next.val){
        //    cur = cur.next;
        // }else{
        //    cur.next = next.next;
        // }

        //非空时 一直循环
        next = next.next
    }

    // 如果是最后几个值是相同的
    cur.next = null

    return list
}

时间复杂度：O(n)
空间复杂度：O(1)
```


## 4 回文链表
https://leetcode.cn/problems/palindrome-linked-list/description/
```java
// 回文链表
// https://leetcode.cn/problems/palindrome-linked-list/description/
//使用stack 无法对[1,0,1] 这样的进行判别
Boolean palindrome(Node list){
    if(list==null) return true;
    Stack<Intege> stack = new Stack()；
    stack.push(Integr.MAX_VALUE);
    while(list!=null){
        if(stack.peek()!=list.val)
            stack.put(list.val)
        else
            stack.pop()
        list = list.next
    }
    return stack.size()==1
}

Boolean palindrome(Node list){
    if(list==null) return true;

    Node slow = list;
    Node fast = list;
    //快慢指针找到中间
    while(slow !=null && fast.next!=null && fast.next.next!=null){
        slow = slow.next;
        fast =fast.next.next ;
    }

    //从中间的下一个开始反转
    Node pre = null;
    Node cur = slow.next;
    Node next = null;

    //反转操作
    while(cur!=null){
        next = cur.next;
        cur.next=pre;
        pre = cur;
        cur = next;
    }

    //将反转后的串儿与输入串相比较
    Node head = pre;
    while(head!=null && list!=null){
        if(head.val!=list.val) return false
        head = head.next;
        list = list.next;
    }

    return true;

}

时间复杂度：O(n)
空间复杂度：O(1)
```

## 5 环形链表
https://leetcode-cn.com/problems/linked-list-cycle/
```java
//环形链表
//https://leetcode-cn.com/problems/linked-list-cycle/
bool cycle(Node list){
    if(list==null) return false;

    Node slow = list;
    Node fast = list;

    while(fast!=null&&fast.next!=null){
        slow = slow.next;
        fast = fast.next.next;
        if(fast == slow) return true;
    }

    return false;

}
时间复杂度：O(n) 空间复杂度：O(1)
```

## 6 环形链表II
https://leetcode-cn.com/problems/linked-list-cycle-ii/
```java
//环形链表II
//https://leetcode-cn.com/problems/linked-list-cycle-ii/
Node detectCycle(Node list){
    if(list==null) return null;

     Node slow = list;
    Node fast = list;

    while(fast!=null&&fast.next!=null){
        slow = slow.next;
        fast = fast.next.next;
        if(fast == slow) break;
    }

    //此时是非相等跳出 说明是非环
    if(fast == null||fast.next==null) return null;

    slow = list;
    while(slow!=null && fast!=null && slow!=fast){
        slow = slow.next;
        fast = fast.next;
    }
    return slow;
}
时间复杂度：O(n) 空间复杂度：O(1)
```

x+y=a 
x+z=2a  
z-y=a
因为相遇时，快的总比慢的多一周 一周周长则为a；

则：x = a-y 即周长减去已走过的长度就是入口点。


## 7 相交链表
https://leetcode-cn.com/problems/intersection-of-two-linked-lists
```java
//相交链表
//https://leetcode-cn.com/problems/intersection-of-two-linked-lists
Node  cross(Node list1,Node list2){
    if(list1==null || list2 == null) return null

    // 获取长度
    Node index = list1;
    int len1 = 0;
    while(index!=null){
        len1++;
        index = index.next;
    }

    // 获取长度
    index = list2;
    int len2= 0;
    while(index!=null){
        len2++;
        index = index.next;
    }

    //获取差值
    Node shortOne = null;
    Node longOne = null;
    int scape = 0;
    if(len1<len2){
        shortOne =  list1;
        longOne = list2;
        scape = len2-len1;
    }else{
        shortOne = list2;
        longOne = list1;
        scape = len1-len2;
    }

    //将长的移动到和短的一样的位置
    while(scape!=0){
        scape--;
        longOne = longOne.next;
    }

    //遍历查找是不是有一样的node，（不是指的值一样）
    while(longOne!=null && shortOne!=null){
        if(longOne == shortOne){
            return longOne;
        }
        longOne=longOne.next;
        shortOne = shortOne.next;
    }


    return null;

}
时间复杂度：O(m+n)
空间复杂度：O(1)
```


## 8 奇偶链表
https://leetcode.cn/problems/odd-even-linked-list/
```java
//奇偶链表
//https://leetcode.cn/problems/odd-even-linked-list/

Node oddEvenList(Node list){
    if(list==null) return null;
    //创建两个新的链表 伪造头节点
    Node oddList = new Node(-1);
    Node oddCur = oddList;
    Node evenList = new Node(-1);
    Node evenCur = evenList;
    //创建当前节点的指示
    Node cur = list;

    //位运算符指示剂
    int flag = 0;

    while(cur!=null){
        //奇数
        if((flag & 0x1) == 0){
            oddCur.next = cur;
            oddCur = cur;
        //偶数
        }else{
            evenCur.next = cur;
            evenCur = cur;
        }

        flag = ~flag;
        cur = cur.next;
    }
    
    //奇数长度的链表 其偶数节点后面有值，要置空。
    if(evenCur!=null) evenCur.next = null;

    //将最后一个odd的next指向evenList的next
    oddCur.next = evenList.next;

    return oddList.next;
}
```

## 9 删除排序链表中的重复元素II
https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii
```java
//删除排序链表中的重复元素II
//https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii

Node repeat(Node head){
    if(head==null) return head;

    Node dummy = new Node(Integer.MAX_VALUE);

    dummy.next = head;

    Node pre = dummy;
    Node cur = head;

    while(cur!=null&& cur.next!=null){
        if(cur.val == cur.next.val){
            int value = cur.val;
            while(cur.next!=null && cur.next.val == value){
                cur = cur.next;
            }
            pre.next = cur.next;
        }else{
            pre = pre.next;
        }

        cur = cur.next;
    }

    return dummy.next;

}

```


## 10 删除链表的倒数第N个节点
https://leetcode.cn/problems/remove-nth-node-from-end-of-list/
```java
//删除链表的倒数第N个节点
//https://leetcode.cn/problems/remove-nth-node-from-end-of-list/

//遍历两次法
// 正数删除第几个元素
Node deletePlus(Node head,int n){
    if(head ==null || n<=0) return head;

    Node dummy = new Node();

    Node pre = dummy;
    Node cur = head;
    dummy.next = head;


    while(n--!=1&& cur!=null){
        pre = pre.next;
        cur = cur.next;
    }

    if(cur!=null){
        pre.next = cur.next;
        cur.next = null;
    }
    return dummy.next;
}

// 倒数删除第几个元素
Node deleteMins(Node head, int n){
    if(head ==null || n<=0) return head;

    Node cur = head;
    int len = 0;

    while(cur!=null){
        len++;
        cur = cur.next;
    }

    // 需要删除的位置
    len = len - n+1;
    
    Node result = deletePlus(head,len)

    return result;
}


// 快慢指针一次
Node delete(Node head,int n){
    if(head ==null || n<=0) return head;

    //这种有可能删除第一个节点的 都用dummy节点比较好
    Node dummy = new Node(0);
    dummy.next = head;
    Node fast = dummy;
    Node slow = dummy;

    //将succ节点向前查找
    while(n--!=0&&fast!=null){
        fast = fast.next;
    }

    // 如果succ节点为空了，说明n的值大于了 链表的长度，直接返回整个链表就行
    if(fast==null) return dummy.next;

    //当fast到最后一个节点，
    while(slow.next!=null&&fast.next!=null){
        slow = slow.next;
        fast = fast.next;
    }

    //slow的下一个就是要删除的节点
    slow.next = slow.next.next; 
    return dummy.next;

}

时间复杂度：O(n)
空间复杂度：O(1)
```

## 11 随机链表的复制
https://leetcode.cn/problems/copy-list-with-random-pointer/description/
```java
//随机链表的复制
//https://leetcode.cn/problems/copy-list-with-random-pointer/description/
Node copy(Node list){
    if(list==null) return list;

    Node dummy = new Node(0);
    Node cur1 = dummy;
    Node cur2 = list
    Map<Node,Node> map = new HashMap();
    while(cur2!=null){
        cur1.next = new Node(cur2.val)
        map.put(cur2,cur1.next);
        cur1 = cur1.next;
        cur2 = cur2.next;
    }
    cur1.next = null;

    cur1 = dummy.next;
    cur2 = list;
    while(cur2!=null){
        Node node = map.get(cur2.random)
        cur1.random = node;
        cur1 = cur1.next;
        cur2 = cur2.next;
    }


    return dummy.next;


}

```

## 12 旋转链表
```java
//旋转链表
//https://leetcode.cn/problems/rotate-list/

Node span(Node list,int k){
    if(list == null||k==0) return list;

    Node cur = list;
    int len = 0;
    //到最后一个不为空的位置 此时长度差1
    while(cur!=null&&cur.next!=null){
        len++;
        cur = cur.next;
    }

    //成环
    cur.next = list;
    len++;

    //针对长度做mod运算 或者实际移动步数；
    k = k%len;

    int offset = len -k;
    Node start = list;
    

    while(offse--!=0){
        start = start.next;
    }
    Node end = start;

    while(len--!=1){
        end= end.next;
    }
    end.next = null;

    return start;

}

```

## 13 两数相加
```java
//两数相加
//https://leetcode.cn/problems/add-two-numbers/

Node sum(Node list1, Node list2){
    if(list1==null && list2==null) return null;

    //虚头点
    Node dummy = new Node(Integer.MAX_VALUE);
    //指针
    Node cur = dummy;
    //进位
    int extra =0;

    //进位非空的时候 也要继续计算
    while(list1!=null||list2!=null||extra!=0){
        //新增节点并移动指针
        cur.next = new Node();
        cur = cur.next;
        
        //获取三个加数
        int a = 0;
        if(list1!=null) a= list1.val;
        
        int b = 0;
        if(list2!=null) b= list2.val;

        //val 赋值
        cur.val = (extra+a+b)%10;
        extra = (extra+a+b)/10;

        //加数链表向前
        if(list1!=null)
            list1 = list1.next;
        if(list2!=null)
            list2 = list2.next;
    
    }

    //返回 虚头之后的节点
    return dummy.next;

}
```


## 14 两两交换链表中的节点
https://leetcode.cn/problems/swap-nodes-in-pairs/

```java
Node swapPairs(head:Node){
    if(head == null || head.next == null) return head;
    Node pre = head;
    Node cur = head.next;
    pre.next = cur.next;
    cur.next = pre;

    pre.next = swapPairs(pre.next);

    return cur;
}

```
