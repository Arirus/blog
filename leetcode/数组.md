## 1 合并两个有序数组
https://leetcode.cn/problems/merge-sorted-array/

```java
//尾插法
void merge(int nums1,int m, int nums2, int n){
    int cur = nums1.length-1;
    int p1 = m-1;
    int p2 = n-1;

    while(cur!=-1){

        // 判断指针合法性
        if(p1 == -1){
            nums1[cur--] = nums2[p2--];
            continue;
        }
        
        // 判断指针合法性
        if(p2 == -1){
            nums1[cur--] = nums1[p1--];
            continue;
        }

        //
        if(nums1[p1]>nums2[p2]){
            nums1[cur--] = nums1[p1--];
        }else {
            nums1[cur--] = nums2[p2--];
        }
    }
}
```

## 2 删除排序数组中的重复项
https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/

```java
public int removeDuplicates(int[] nums) {
    if(nums.length == 0 ) return 0;

    int cur = 0;
    int dec = 1;

    while(dec!=nums.length){
        if(nums[cur] == nums[dec])
            dec++;
        else{
            nums[++cur] = nums[dec++];
        }
    }

    return cur+1;
}
```

## 3 移动零
https://leetcode.cn/problems/move-zeroes/
```java
public void moveZeroes(int[] nums) {
    if(nums.length == 0) return ;
    int p1 = 0;
    int p2 = 0;
    while(p2!=nums.length){
        if(nums[p2]!=0){
            nums[p1++] = nums[p2];
        }
        p2++;
    }
    while(p1!=nums.length){
        nums[p1++] = 0;
    }
}
```

## 4 两个数组的交集
https://leetcode.cn/problems/intersection-of-two-arrays/description/

```java
//使用hash 
public int[] intersection(int[] nums1, int[] nums2) {
    if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) {
        return new int[0];
    }
    Set<Integer> set1 = new HashSet<>();
    Set<Integer> resSet = new HashSet<>();
    //遍历数组1
    for (int i : nums1) {
        set1.add(i);
    }
    //遍历数组2的过程中判断哈希表中是否存在该元素
    for (int i : nums2) {
        if (set1.contains(i)) {
            resSet.add(i);
        }
    }
    //将结果几何转为数组
    return resSet.stream().mapToInt(x -> x).toArray();
}
```

## 5 两数之和
https://leetcode.cn/problems/two-sum/

```java
public int[] twoSum(int[] nums, int target) {
    int[] result=new int[2];
    int cur = 0;
    while(cur!=nums.length){
        int dec = cur+1;
        while(dec!=nums.length){
            if(nums[cur]+nums[dec]==target){
                result[0] = cur;
                result[1] = dec;
                return result;
            }
            dec++;
        }
        cur++;
    }
    return result ;
}
O(n^2)

//使用hash
public int[] twoSum(int[] nums, int target) {
    int[] result=new int[2];
    HashMap<Integer,Integer> map = new HashMap();
    for(int i = 0;i<nums.length;i++){
        int sub = target - nums[i];
        if(map.get(sub)!=null){
            result[0] = i;
            result[1] = map.get(sub);
            break;
        }else{
            map.put(nums[i],i);
        }

    }
    return result ;
}
```

## 6 加一
https://leetcode.cn/problems/plus-one/description/

```java
public int[] plusOne(int[] digits) {
    int extra = 1;
    int mod = 0;
    for(int i= digits.length-1;i>=0;i--){
        mod = (digits[i]+extra)%10;
        extra = (digits[i]+extra)/10;
        digits[i] = mod;
    }
    if(extra==0) return digits;
    
    int[] result = new int[digits.length+1];
    for(int i= digits.length-1;i>=0;i--){
        result[i+1] = digits[i];
    }
    result[0]=1;
    return result;
}
```