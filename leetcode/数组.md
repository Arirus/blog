# 数组理论基础
- 数组下标都是从0开始的。 
- 数组在内存空间的地址是连续的。

## 二分查找
https://leetcode.cn/problems/binary-search/

```java
// 遍历 时间复杂度O（n） 空间复杂度1
public int search(int[] nums, int target) {
    if(nums.length == 0) return -1;
    int result = 0;
    while(result<nums.length){
        if(target == nums[result]) return result;
        result++;
    }
    return -1
}

```

二分框架，注意几个细节：
- 不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节
- 代码中 left + (right - left) / 2 防止溢出
- 右值的确定 是 nums.length 还是 nums.length-1
- 中断条件是 left < right 还是 left <= right
- 更新边界条件 left = mid 还是 left = mid+1 同理 right
- 返回值是什么

这里给出两种方案
```java
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}

// 方式1，前闭后闭 区间
// 遍历 时间复杂度O（lgn） 空间复杂度1
int binarySearch(int[] nums, int target) {
    if(nums.length == 0) return -1;
    int left = 0, right = nums.length-1;

    while(left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid+1;
        } else if (nums[mid] > target) {
            right = mid-1;
        }
    }
    return -1;
}

// 方式2，前闭后开 区间
int binarySearch(int[] nums, int target) {
    if(nums.length == 0) return -1;
    int left = 0, right = nums.length;

    while(left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid+1;
        } else if (nums[mid] > target) {
            right = mid;
        }
    }
    return -1;
}
```

## 移除元素
https://leetcode.cn/problems/remove-element/

[3,2,2,3]
3
[0,1,2,2,3,0,4,2]
2

```java
// 遍历 时间复杂度O（n） 空间复杂度1
public int removeElement(int[] nums, int val) {
    //双指针
    if(nums.length == 0) return 0;
    int cur = 0;
    int next = 0;

    while(next<nums.length){
        if(nums[next] != val){
            // 此时将后值赋给前值
            nums[cur++] = nums[next];
        }
        next++;
    }
    //cur 已经++ 这里无需+1
    return cur;
}
```

## 长度最小的子数组
https://leetcode.cn/problems/minimum-size-subarray-sum/
```java
//滑动窗口
//时间复杂度：O(n) 空间复杂度 O（1）
public int minSubArrayLen(int target, int[] nums) {
    if(nums.length == 0) return 0;

    int sum =0 ;
    int result = Integer.MAX_VALUE;
    int left = 0,right = 0;
    //sum 初始值为0 不然没办法每次在循环里+
    while(right<nums.length){
        sum+=nums[right];
        // 当总值大于阈值时
        // 这里也要等于 因为 可以能有多个 要获取最小的
        while(sum >= target){
            //获取最小的
            result = Math.min(result, right - left + 1);
            sum-=nums[left];
            left++;
        }
        right++;
    }

    return result == Integer.MAX_VALUE ? 0 : result;
}


//暴力法
//时间复杂度：O(n^2) 空间复杂度 O（1）
public int minSubArrayLen(int target, int[] nums) {
    if(nums.length == 0) return 0;
    int result = Integer.MAX_VALUE;
    for(int i=0;i<nums.length; i++){
        int sum = 0;
        for(int j=i;j<nums.length;j++){
            sum+=nums[j];
            if(sum>=target){
                result = Math.min(result, j - i + 1);
                break;
            }
        }
    }
    return result == Integer.MAX_VALUE ? 0 : result;
}
```

## 螺旋矩阵 II
https://leetcode.cn/problems/spiral-matrix-ii/

```java
public int[][] generateMatrix(int n) {
    if(n<=0) return null;
    int loop = 0;  // 控制循环次数
    int[][] res = new int[n][n];
    int start = 0;  // 每次循环的开始点(start, start)
    int value = 1;  // 定义填充数字
    int i, j;

    while (loop++ < n / 2) { // 判断边界后，loop从1开始
        // 模拟上侧从左到右
        for (j = start; j < n - loop; j++) {
            res[start][j] = value++;
        }

        // 模拟右侧从上到下
        for (i = start; i < n - loop; i++) {
            res[i][j] = value++;
        }

        // 模拟下侧从右到左
        for (; j >= loop; j--) {
            res[i][j] = value++;
        }

        // 模拟左侧从下到上
        for (; i >= loop; i--) {
            res[i][j] = value++;
        }
        start++;
    }

    if (n % 2 == 1) {
        res[start][start] = count;
    }

    return res;

}
```


## 1 合并两个有序数组
https://leetcode.cn/problems/merge-sorted-array/

```java
//尾插法
void merge(int nums1,int m, int nums2, int n){
    int cur = nums1.length-1;
    int p1 = m-1;
    int p2 = n-1;

    while(cur!=-1){

        // 判断指针合法性
        if(p1 == -1){
            nums1[cur--] = nums2[p2--];
            continue;
        }
        
        // 判断指针合法性
        if(p2 == -1){
            nums1[cur--] = nums1[p1--];
            continue;
        }

        //
        if(nums1[p1]>nums2[p2]){
            nums1[cur--] = nums1[p1--];
        }else {
            nums1[cur--] = nums2[p2--];
        }
    }
}
```

## 2 删除排序数组中的重复项
https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/

```java
public int removeDuplicates(int[] nums) {
    if(nums.length == 0 ) return 0;

    int cur = 0;
    int dec = 1;

    while(dec!=nums.length){
        if(nums[cur] == nums[dec])
            dec++;
        else{
            nums[++cur] = nums[dec++];
        }
    }

    return cur+1;
}
```

## 3 移动零
https://leetcode.cn/problems/move-zeroes/
```java
public void moveZeroes(int[] nums) {
    if(nums.length == 0) return ;
    int p1 = 0;
    int p2 = 0;
    while(p2!=nums.length){
        if(nums[p2]!=0){
            nums[p1++] = nums[p2];
        }
        p2++;
    }
    while(p1!=nums.length){
        nums[p1++] = 0;
    }
}
```

## 4 两个数组的交集
https://leetcode.cn/problems/intersection-of-two-arrays/description/

```java
//使用hash 
public int[] intersection(int[] nums1, int[] nums2) {
    if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) {
        return new int[0];
    }
    Set<Integer> set1 = new HashSet<>();
    Set<Integer> resSet = new HashSet<>();
    //遍历数组1
    for (int i : nums1) {
        set1.add(i);
    }
    //遍历数组2的过程中判断哈希表中是否存在该元素
    for (int i : nums2) {
        if (set1.contains(i)) {
            resSet.add(i);
        }
    }
    //将结果几何转为数组
    return resSet.stream().mapToInt(x -> x).toArray();
}
```

## 5 两数之和
https://leetcode.cn/problems/two-sum/

```java
public int[] twoSum(int[] nums, int target) {
    int[] result=new int[2];
    int cur = 0;
    while(cur!=nums.length){
        int dec = cur+1;
        while(dec!=nums.length){
            if(nums[cur]+nums[dec]==target){
                result[0] = cur;
                result[1] = dec;
                return result;
            }
            dec++;
        }
        cur++;
    }
    return result ;
}
O(n^2)

//使用hash
public int[] twoSum(int[] nums, int target) {
    int[] result=new int[2];
    HashMap<Integer,Integer> map = new HashMap();
    for(int i = 0;i<nums.length;i++){
        int sub = target - nums[i];
        if(map.get(sub)!=null){
            result[0] = i;
            result[1] = map.get(sub);
            break;
        }else{
            map.put(nums[i],i);
        }

    }
    return result ;
}
```

## 6 加一
https://leetcode.cn/problems/plus-one/description/

```java
public int[] plusOne(int[] digits) {
    int extra = 1;
    int mod = 0;
    for(int i= digits.length-1;i>=0;i--){
        mod = (digits[i]+extra)%10;
        extra = (digits[i]+extra)/10;
        digits[i] = mod;
    }
    if(extra==0) return digits;
    
    int[] result = new int[digits.length+1];
    for(int i= digits.length-1;i>=0;i--){
        result[i+1] = digits[i];
    }
    result[0]=1;
    return result;
}
```