## 基础
- 满二叉树：只有0子树和2子树，无1子树的。
- 完全二叉树：除了底层节点可能没填满,具余每层的节点数都达到最大值。并且底层的节点都集中在该层最左边的若干位置。
- 二叉搜索树：二叉搜索树是-个有序树, 满足如下规则
  - 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值
  - 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值
  - 它的左右子树也分别为二叉排序树。
- 平衡二叉搜索树：它是-棵空树，或者它的左右两个子树的高度差的绝对值不超过1并且左右两个子树都是1棵平衡二叉树。

## DFS 遍历
### 先序遍历
```java
//递归版本
void preOrderTraversal(Node root){
    if(root == null) return;

    println(root.val);
    preOrderTraversal(root.left);
    preOrderTraversal(root.right);
}

void preOrderTraversal(Node root){
    if(root == null) return;

    Stack<Node> stack  = new Stack();
    stack.push(root);
    while(!stack.isEmpty()){
        Node cur = stack.pop();

        println(cur.val);
        //由于栈的特性 先进后出，因此要先展示左节点，那么要右节点先进入。
        if(cur.right!=null)
            stack.push(cur.right);

        if(cur.left!=null)
            stack.push(cur.left);
    }
}
```

### 中序遍历
```java
void inOrderTraversal(Node root){
    if(root == null) return;

    Stack<Node> stack  = new Stack();
    Node cur = root;

    while(cur!=null || !stack.isEmpty()){
        //非先展示
        while(cur!=null){
            stack.push(cur);
            cur = cur.left;
        }

        cur = stack.pop();
        println(cur.val);
        cur = cur.right;
    }
}

```

### 后序遍历
```java
void postOrderTraversal(Node root){
    if(root == null) return;

    Stack<Node> stack  = new Stack();
    Node cur = root;
    Node preVisited = null;

    while(cur!=null || !stack.isEmpty()){
        // 非优先展示
        while(cur!=null){
            stack.push(cur);
            cur = cur.left;
        }

        Node peek = stack.peek();
        if(peek.right!=null && peek.right!=preVisited){
            cur = peek.right;
        }else{
            println(peek.val);
            preVisited = stack.pop();
        }
    }
}

后序遍历的顺序是左->右->中 ,只需要调整前序遍历的代码顺序变成中->右->左的遍历顺序 然后反转result数组.输出结果的顺序就星左->右->中了
或者将结果传入一个result栈，顺序出栈就可以
```

统一写法：
```java
List<Integer> OrderTraversal(Node root){ 
    if(root == null) return;
    List<Integer> result = new LinkedList<>();
    Stack<Node> stack = new Stack<>();
    stack.push(root);

    while (!stack.isEmpty()) {
        Node cur = stack.pop();

        if (cur != null) {
            // 这个是前序遍历 反向入栈。同理可以写 中序 和 后续
            if (cur.right != null) stack.push(cur.right);
            if (cur.left != null) stack.push(cur.left);
            stack.push(cur);
            stack.push(null);
        } else {
            cur = stack.pop();
            result.add(cur.value);
        }
    }

    return result;
}
```

## BFS 遍历
```java
void  BFS(Node tree){
    if(tree == null) return;
    Quene<Node> quene = new ArrayQuene();

    quene.add(tree);
    while(!quene.isEmpty()){
        Node cur = quene.poll();
        println(cur.val);

        if(tree.left!=null) queue.add(tree.left);
        if(tree.right!=null) queue.add(tree.right);
    }

}
```
## 反转二叉树
https://leetcode.cn/problems/invert-binary-tree/description/
```java
//二叉树相关操作可以考虑递归
//这里是直接将 root 左右子树进行对调
public TreeNode invertTree(TreeNode root) { 
    if(root == null) return root;
    TreeNode left = root.left;
    TreeNode right = root.right;
    root.left = invertTree(right);
    root.right = invertTree(left);
    return root;
}

// 还可以通过遍历的方案
public TreeNode invertTree(TreeNode root) {
    if(root == null) return root;
    Queue<TreeNode> queue = new LinkedList();
    queue.offer(root);
    while(!queue.isEmpty()){
        TreeNode cur = queue.poll();
        if(cur.left!=null || cur.right != null){
            TreeNode left = cur.left;
            TreeNode right = cur.right;
            cur.right = left;
            cur.left = right;
            if(left!=null) queue.offer(left);
            if(right!=null) queue.offer(right);
        }
    }

    return root;
}
```

## 对称二叉树
https://leetcode.cn/problems/symmetric-tree/description/

```java
boolean isSymmetric(Node root){
    if(root==null)return true;

    return dfs(root.left,root.right);
}

boolean dfs(Node left,Node right){
    if(left == null && right == null) return true;
    if(left == null || right == null) return false;
    if(left.val!=right.val) return false;
    return dfs(left.left,right.right) && dfs(lift.right,right.left);
}
```

## 二叉树的最大深度
https://leetcode.cn/problems/maximum-depth-of-binary-tree/

```java
// 使用递归
public int maxDepth(TreeNode root) {
    if(root == null) return 0;
    int depthLeft = maxDepth(root.left);
    int depthRight = maxDepth(root.right);
    return 1+Math.max(depthLeft,depthRight);
}

//使用层序遍历
int maxDepth(Node node){
    if(node == null) return 0;
    Deque<Node> deque = new ArrayDeque();

    deque.add(node);
    int depth = 0;
    while(!deque.isEmpty()){
        int n = deque.size();
        depth++;
        for(int i=0;i<n;i++){
            Node cur = deque.poll();

            if(cur.left!=null) deque.add(cur.left);
            if(cur.right!=null) deque.add(cur.right);
        }

    }

    return depeth;
}

```
## 二叉树的最小深度
https://leetcode.cn/problems/minimum-depth-of-binary-tree/
```java
// 类似最大深度，当一个节点没有左右孩子就是叶子结点
public int minDepth(TreeNode node) {
    if(node == null) return 0;
    Deque<TreeNode> deque = new ArrayDeque();

    deque.add(node);
    int depth = 0;
    while(!deque.isEmpty()){
        int n = deque.size();
        depth++;
        for(int i=0;i<n;i++){
            TreeNode cur = deque.poll();
            if(cur.left == null && cur.right==null) return depth;

            if(cur.left!=null) deque.add(cur.left);
            if(cur.right!=null) deque.add(cur.right);
        }

    }

    return depth;
}
```

## 平衡二叉树
https://leetcode.cn/problems/balanced-binary-tree/description/
```java

boolean AVL(Node tree){
    if(tree == null) return true;
    

    return  Math.abs(deepth(tree.left)-deepth(tree.right))<=1 && AVL(tree.left) && AVL(tree.right);
}

int deepth(Node tree){
    if(tree == null) return 0;

    return 1+Math.max(deepth(tree.left),deepth(tree.right));
}
O(nlogn) O(n)

// 不可以使用层序遍历 获取最大深度 和 最小深度，然后求二者的差值。因为对于降级为单链表的树，最大深度和最小深度是相等的，此时其差值为0，但是为非AVL。
// 缺陷：对于同一个节点，函数 deepth 会被重复调用，导致时间复杂度较高
// 使用自底向上的递归，对于每个节点，函数 deepth 只会被调用一次。
boolean AVL(Node tree){
    return height(tree) >= 0;
}
public int height(Node root) {
    if (root == null) {
        return 0;
    }
    int leftHeight = height(root.left);
    int rightHeight = height(root.right);
    if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1) {
        return -1;
    } else {
        return Math.max(leftHeight, rightHeight) + 1;
    }
}

```

## 二叉树的所有路径
https://leetcode.cn/problems/binary-tree-paths/description/

```java
List<String> treePaths(Node root){
    if(root == null) return null;
    List<String> paths = new LinkList();

    doSearch(root,"",paths);

    return paths
}

void doSearch(Node root, String path, List<String> paths){
    if(root == null) return root;

    path+=root.val;
    if(root.left==null&&root.right==null) paths.add(path);
    doSearch(root.left,path+"->",paths);
    doSearch(root.right,path+"->",paths);

}


//递归解法
List<String> treePaths(Node root){
    List<String> paths = new LinkList();
    if(root==null) return paths;

    if(root.left==null&& root.right==null) {
        paths.add(root.val+"");
        return paths;
    }

    for (String path:treePaths(root.left)){
        paths.add(root.val +"->" +path);
    }
    for (String path:treePaths(root.right)){
        paths.add(root.val +"->" +path);
    }
    return paths;
}
```
## 路径总和
https://leetcode.cn/problems/path-sum/description/

```java
public boolean hasPathSum(TreeNode root, int targetSum) {
    //中断条件
    if(root == null) return false;
    //此时是叶子结点
    if(root.left == null && root.right == null && root.val == targetSum) return true;

    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);
}


// 非递归考虑使用BFS，维护两个队列，分别是当前的Node和当前的总和
public boolean hasPathSum(TreeNode root, int targetSum) {
    if(root == null) return false;
    Queue<TreeNode> queNode = new LinkedList();
    Queue<Integer> queResult = new LinkedList();

    queNode.offer(root);
    queResult.offer(root.val);

    while(!queNode.isEmpty()){
        TreeNode cur = queNode.poll();
        int curSum = queResult.poll();
        if(cur.left == null && cur.right == null && curSum == targetSum) return true;
        if(cur.left!=null){
            queNode.offer(cur.left);
            queResult.offer(cur.left.val+curSum);
        }
        if(cur.right!=null){
            queNode.offer(cur.right);
            queResult.offer(cur.right.val+curSum);
        }
    }
    return false;
}
```

## 路径总和2
https://leetcode.cn/problems/path-sum-ii/

```java
public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
    List<List<Integer>> result = new LinkedList();
    Stack<Integer> path = new Stack();
    if(root==null) return result;
    doSearch(root,targetSum,path,result);
    return result;
}

// 开启循环，path 中维护根节点到当前点的路径 与二叉树的所有路径类似
void doSearch(TreeNode root, int targetSum,Stack<Integer> path,List<List<Integer>> result){
    if(root == null) return;
    path.push(root.val);
    if(root.left == null && root.right == null && targetSum == root.val){
        result.add(new LinkedList<Integer>(path));
    }
    doSearch(root.left, targetSum-root.val,path,result);
    doSearch(root.right, targetSum-root.val,path,result);
    //这里pop是因为path是一个stack，按引用传递，因此这里要移除本次插入
    path.pop();
}

// 也可以使用BFS来进行查找

public void getPath(TreeNode node) {
    List<Integer> temp = new LinkedList<Integer>();
    while (node != null) {
        temp.add(node.val);
        node = map.get(node);
    }
    Collections.reverse(temp);
    ret.add(new LinkedList<Integer>(temp));
}

public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
    if(root==null) return null;
    Queue<TreeNode> queueNode = new LinkedList<TreeNode>();
    Queue<Integer> queueSum = new LinkedList<Integer>();
    List<List<Integer>> ret = new LinkedList<List<Integer>>();
    //path 路径的构成的多条链 这里不能用list，因为可能同时两个叶子结点进入，当 node.left == null && node.right == null 成立时，map中是有干扰项的
    Map<TreeNode, TreeNode> map = new HashMap<TreeNode, TreeNode>();
    queueNode.offer(root);
    queueSum.offer(0);

    while(!queueNode.isEmpty()){
        TreeNode node = queueNode.poll();
        int rec = queueSum.poll() + node.val;

        if(node.left == null && node.right == null){
            if(rec == targetSum){
                getPath(node);
            }
        }else{
            if (node.left != null) {
                map.put(node.left, node);
                queueNode.offer(node.left);
                queueSum.offer(rec);
            }
            if (node.right != null) {
                map.put(node.right, node);
                queueNode.offer(node.right);
                queueSum.offer(rec);
            }
        }

    }

    return result;
}
```

## 路径总和3
https://leetcode.cn/problems/path-sum-iii
```java
public int pathSum(TreeNode root, int targetSum) {
    if(root == null) return 0;
    int result = 0;
    result = doSearch(root,targetSum);
    result+=pathSum(root.left,targetSum);
    result+=pathSum(root.right,targetSum);

    return result;
}

public int doSearch(TreeNode root, int targetSum){
    if(root == null) return 0;
    int result = 0;
    //不一定是叶子结点 不用加左右判空
    if(root.val == targetSum){
        result = 1;
    }

    result += doSearch(root.left,targetSum-root.val);
    result += doSearch(root.right,targetSum-root.val);
    return result;
}
```

## 从中序与后序遍历序列构造二叉树
https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/

```java
public TreeNode buildTree(int[] inorder, int[] postorder) {
    //用来存储中序遍历的 value 和 index
    Map<Integer,Integer> map = new HashMap();
    //后续遍历整体保存起来。
    int [] post = postorder;

    for(int i =0; i<inorder.length;i++){
        map.put(inorder[i],  i);
    }

    //构造跟结点
    TreeNode root = cons(0,inorder.length-1,0,postorder.length-1,map,post);


    return root;
}

public TreeNode cons(int is, int ie, int ps, int pe,Map<Integer,Integer> map,int [] post){
    //跳出条件
    if(ie < is || pe < ps) return null;

    TreeNode node = new TreeNode();
    node.val = post[pe];

    int index = map.get(node.val);

    node.left = cons(is,index-1,ps,ps-is+index-1,map,post);
    node.right =cons(index+1,ie,ps-is+index,pe-1,map,post) ;

    return node;
}
```

## 使用前序与中序遍历序列构造二叉树
https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

```java
//用来存储中序遍历的 value 和 index
Map<Integer,Integer> map = new HashMap();
//后续遍历整体保存起来。
int[] pre = null;

public TreeNode buildTree(int[] preorder, int[] inorder) {
    pre = preorder;
    for(int i = 0;i<inorder.length;i++){
        map.put(inorder[i],i);
    }

    TreeNode node = cons(0,preorder.length-1,0,inorder.length-1);

    return node;
}

public TreeNode cons(int ps,int pe,int is,int ie){
    if(ps>pe || is>ie) return null;

    TreeNode root = new TreeNode(pre[ps]);
    int index = map.get(root.val);
    root.left = cons(ps+1,ps-is+index,is,index-1);
    root.right = cons(ps-is+index+1,pe,index+1,ie);

    return root;
}
// 整体思路同上
O(n) O(n)
```
前序数组租后序数组不能唯-确定_棵二叉树|这是因为没有中序遍历就无法确定左右区间) 即无法确定分割点

## 合并二叉树
https://leetcode-cn.com/problems/merge-two-binary-trees/

```java
// 本质上还是DFS
Node merge(Node root1, Node root2){
    if(root1 == null )return root2;
    if(root2 == null) return root1;

    root1.val+=root2.val;
    root1.left = merge(root1.left,root2.left);
    root1.right = merge(root1.right,root2.right);
    return root1;
}
O(n) O(logn) 树的高度（迭代的次数）

Node merge(Node root1, Node root2){
    if(root1 == null )return root2;
    if(root2 == null) return root1;

    Queue<TreeNode> queue = new LinkedList();
    queue.offer(root1);
    queue.offer(root2);

    while(!queue.isEmpty()){
        TreeNode n1 = queue.poll();
        TreeNode n2 = queue.poll();
        if(n1!=null && n2!=null){
            n1.val = n1.val+n2.val;
        }
        if(n1.left!=null && n2.left!=null){
            queue.offer(n1.left);
            queue.offer(n2.left);
        } else if(n1.left == null){
            n1.left = n2.left;
        }

        if(n1.right!=null && n2.right!=null){
            queue.offer(n1.right);
            queue.offer(n2.right);
        } else if(n1.right == null){
            n1.right = n2.right;
        }
    }

    
    return root1;
}

```

## 二叉搜索树中的搜索
https://leetcode.cn/problems/search-in-a-binary-search-tree/description/

```java
// 递归使用DFS
public TreeNode searchBST(TreeNode root, int val) {
    if(root == null) return root;

    if(root.val > val){
        return searchBST(root.left, val);
    }else if(root.val < val){
        return searchBST(root.right, val);
    }

    return root;
}

// 迭代使用BFS
public TreeNode searchBST(TreeNode root, int val) {
    if(root == null) return root;
    Queue<TreeNode> queue = new LinkedList();
    queue.offer(root);

    while(!queue.isEmpty()){
        TreeNode cur = queue.poll();
        if(cur.val == val){
            return cur;
        }else if(cur.val>val && cur.left!=null){
            queue.offer(cur.left);
        }else if(cur.val<val && cur.right!=null){
            queue.offer(cur.right);
        }else{
            break;
        }
    }
    return null;
}
// BST是有序的，因此不用额外的数据结构也能进行迭代。
public TreeNode searchBST(TreeNode root, int val) {
    if(root == null) return root;
    while(root != null){
        if(root.val>val ) root = root.left;
        else if(root.val<val ) root = root.right;
        else return root;
    }
    return null;
}
```

## 验证二叉搜索树
https://leetcode.cn/problems/validate-binary-search-tree/description/

```java
// 错误解法：判断每个子树都是BST，这样不行是由于你只是比较了根结点和两个子树，而不是两个子树的最小值。
public boolean isValidBST(TreeNode root) {
    if(root == null) return true;
    if(root.left!=null && root.left.val >= root.val) return false;
    if(root.right!=null && root.right.val <= root.val) return false;

    return isValidBST(root.left) && isValidBST(root.right);
}


// 二叉搜索树 中序遍历 本质就是 前一个要比后一个小 ，因此主要判断当前root节点是不是比前一个大，如果是的话 那就是 不是的话 就不是。
Integer pre = null;
boolean BST(Node root){
    // 空树或者空节点 认为是 BST
    if(root==null) return true;

    // 判断左树是不是；
    boolean left = BST(root.left);

    // 判断当前节点是不是，同时要更新比较对象 pre
    if(pre!=null&&pre>=root.val) return false;
    pre = root.val; 

    // 判断右树是不是；
    boolean right = BST(root.right);

    //返回整体判断
    return left && right;

}

// 因为二叉搜索树 中序 就是一个有序的数组。那么将其退化为一个数组 再进行判断
boolean BST(Node root){
    if(root == null) return true;

    Stack<Node> stack = new Stack();
    //遍历内容放回到 stack 中
    traversal(root,stack);

    Node pre = null;
    while(!stack.isEmpty()){
        Node cur = stack.pop();
        // pre 是大值。如果出现小值比他大那么是有问题的。
        if(pre!=null && pre.val<=cur.val) return false;
        pre = cur;
    }
    return true;
}

// 递归进行中序遍历
void traversal(Node root, Stack<Node> stack){
    if(root == null) return ;

    traversal(root.left,stack);
    stack(root);
    traversal(root.right,stack);
}

```

## 二叉搜索树的最小绝对差
https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/

```java

```



## 1 将有序数组转换为二叉搜索树
https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree

```java
class Node{
    int val;
    Node left;
    Node right;
}
```

```java

// BST root节点一定是中间值
Node arrayToTree(int[] nums){
    if(nums == null || nums.length == 0) return null;
    //递归方式进行
    return toTree(nums,0,nums.length-1);

}

Node toTree(int[] nums, int start ,int end){
    Node root = null;
    //跳出条件
    if(start > end) return root;
    
    //相当于取小了
    int mid = (start+end)>>1;

    
    root = new Node(nums[mid]);
    //mid不再参与树化
    root.left = toTree(nums,start,mid-1);
    root.right = toTree(nums,mid+1,end);
    return root;
}


```

## 2 二叉搜索树的最近公共祖先
https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
```java

// 主要是使用二叉搜索树 根节点的性质（大于左子树，小于右子树）
Node lowestCommonAncestor(Node root,Node p,Node q){
    if(root == null) return root;
    Node small = p;
    Node large = q;
    if(p.val>q.val){
        small = q;
        large = p;
    }

    return doSeach(root,small,large);
}


Node doSearch(Node root,Node p,Node q){
    //这个可以不加 如果 p q 不一定是树里的值的话 要加
    if(root==null) return root;
    //如果当前节点 大于小的 小于大的 那说明就是他
    if(root.val>p.val&&root.val<q.val){
        return root;
        //比小的还小 那要看他的右子树
    }else if(root.val<p.val){
        return doSearch(root.right,p,q);
        //比大的还大 那要看他的左子树
    }else if(root.val>q.val){
        return doSearch(root.left,p,q);
    }else{
        // 其中有相等的 说明就是这个节点
        return root.val==p.val?p:q;
    }
}

```

## 3 二叉树的最近公共祖先
https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/
```java
//非搜索树，无法使用大小判断 只能通过遍历查询。
//p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；
//p=root ，且 q 在 root 的左或右子树中；
//q=root ，且 p 在 root 的左或右子树中；

// left == null && right == null -> p q 即不在左树又不在右树；
// left ！= null && right == null -> p q 都在左树中
// left == null && right ！= null -> p q 都在右树中
// left ！= null && right ！= null -> p q 分别在左右树中 root为最近公共祖先

Node lowestCommonAncestor(Node root, Node p, Node q){
    if(root == null || root == p || root == q) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if(left == null) return right;
    if(right == null) return left;
    return root;
}

```

## 5 二叉搜索树中第K小的元素
https://leetcode.cn/problems/kth-smallest-element-in-a-bst/
// 对于搜索树 还是多考虑中序遍历 使之有序，然后再做操作
```java
int k;
int result;
// 全局存储 索引和结果；
public int kthSmallest(TreeNode root, int _k) {
    k = _k;
    doSearch(root)
    return result;
}

void doSearch(TreeNode root){
    //当索引为0时 认为已经找到 不需要遍历。
    if(k==0||root==null) return;

    doSearch(root.left);
    if(--k==0) {
        result = root.val;
        return;
    }
    doSearch(root.right);

}
```




## 6 二叉树的层次遍历
https://leetcode.cn/problems/binary-tree-level-order-traversal/description/

```java
void  BFS(Node tree){
    if(tree == null) return;
    Quene<Node> quene = new ArrayQuene();

    quene.add(tree);
    while(!quene.isEmpty()){
        //记录当前的个数 作为层数。
        int n = queue.size();
        for（int i=0;i<n;i++）{
            Node cur = quene.poll();
            println(cur.val);

            if(tree.left!=null) queue.add(tree.left);
            if(tree.right!=null) queue.add(tree.right);
        }
        println(“\n”);
    }

}
```



## 9 求根到叶子节点数字之和
https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/
```java
//思路同上 不过不在是字符串 而是int
int sums(Node root){
    if(root == null) return 0;
    List<Integer> nums = new LinkedList();

    doTraversal(root,0,nums);

    int sum = 0;
    nums.forEach((num)->{
        sum+=num;
    })
    return sum;
}

void doTraversal(Node root,int num, List<Integer> nums){
    if(root == null) return;
    num = num*10+root.val;
    if(root.left == null && root.right == null) nums.add(num);
    doTraversal(root.left,num,nums);
    doTraversal(root.right,num,nums);
}
```