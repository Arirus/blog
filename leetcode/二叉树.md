## 基础
- 满二叉树：只有0子树和2子树，无1子树的。
- 完全二叉树：除了底层节点可能没填满,具余每层的节点数都达到最大值。并且底层的节点都集中在该层最左边的若干位置。
- 二叉搜索树：二叉搜索树是-个有序树, 满足如下规则
  - 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值
  - 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值
  - 它的左右子树也分别为二叉排序树。
- 平衡二叉搜索树：它是-棵空树，或者它的左右两个子树的高度差的绝对值不超过1并且左右两个子树都是1棵平衡二叉树。

## DFS 遍历
### 先序遍历
```java
//递归版本
void preOrderTraversal(Node root){
    if(root == null) return;

    println(root.val);
    preOrderTraversal(root.left);
    preOrderTraversal(root.right);
}

void preOrderTraversal(Node root){
    if(root == null) return;

    Stack<Node> stack  = new Stack();
    stack.push(root);
    while(!stack.isEmpty()){
        Node cur = stack.pop();

        println(cur.val);
        //由于栈的特性 先进后出，因此要先展示左节点，那么要右节点先进入。
        if(cur.right!=null)
            stack.push(cur.right);

        if(cur.left!=null)
            stack.push(cur.left);
    }
}
```

### 中序遍历
```java
void inOrderTraversal(Node root){
    if(root == null) return;

    Stack<Node> stack  = new Stack();
    Node cur = root;

    while(cur!=null || !stack.isEmpty()){
        //非先展示
        while(cur!=null){
            stack.push(cur);
            cur = cur.left;
        }

        cur = stack.pop();
        println(cur.val);
        cur = cur.right;
    }
}

```

### 后序遍历
```java
void postOrderTraversal(Node root){
    if(root == null) return;

    Stack<Node> stack  = new Stack();
    Node cur = root;
    Node preVisited = null;

    while(cur!=null || !stack.isEmpty()){
        while(cur!=null){
            stack.push(cur);
            cur = cur.left;
        }

        Node peek = stack.peek();
        if(peek.right!=null && peek.right!=preVisited){
            cur = peek.right;
        }else{
            println(peek.val);
            preVisited = stack.pop();
        }
    }
}

```

## BFS 遍历
```java
void  BFS(Node tree){
    if(tree == null) return;
    Quene<Node> quene = new ArrayQuene();

    quene.add(tree);
    while(!quene.isEmpty()){
        Node cur = quene.poll();
        println(cur.val);

        if(tree.left!=null) queue.add(tree.left);
        if(tree.right!=null) queue.add(tree.right);
    }

}
```


## 1 将有序数组转换为二叉搜索树
https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree

```java
class Node{
    int val;
    Node left;
    Node right;
}
```

```java

// BST root节点一定是中间值
Node arrayToTree(int[] nums){
    if(nums == null || nums.length == 0) return null;
    //递归方式进行
    return toTree(nums,0,nums.length-1);

}

Node toTree(int[] nums, int start ,int end){
    Node root = null;
    //跳出条件
    if(start > end) return root;
    
    //相当于取小了
    int mid = (start+end)>>1;

    
    root = new Node(nums[mid]);
    //mid不再参与树化
    root.left = toTree(nums,start,mid-1);
    root.right = toTree(nums,mid+1,end);
    return root;
}


```

## 2 二叉搜索树的最近公共祖先
https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
```java

// 主要是使用二叉搜索树 根节点的性质（大于左子树，小于右子树）
Node lowestCommonAncestor(Node root,Node p,Node q){
    if(root == null) return root;
    Node small = p;
    Node large = q;
    if(p.val>q.val){
        small = q;
        large = p;
    }

    return doSeach(root,small,large);
}


Node doSearch(Node root,Node p,Node q){
    //这个可以不加 如果 p q 不一定是树里的值的话 要加
    if(root==null) return root;
    //如果当前节点 大于小的 小于大的 那说明就是他
    if(root.val>p.val&&root.val<q.val){
        return root;
        //比小的还小 那要看他的右子树
    }else if(root.val<p.val){
        return doSearch(root.right,p,q);
        //比大的还大 那要看他的左子树
    }else if(root.val>q.val){
        return doSearch(root.left,p,q);
    }else{
        // 其中有相等的 说明就是这个节点
        return root.val==p.val?p:q;
    }
}

```

## 3 二叉树的最近公共祖先
https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/
```java
//非搜索树，无法使用大小判断 只能通过遍历查询。
//p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；
//p=root ，且 q 在 root 的左或右子树中；
//q=root ，且 p 在 root 的左或右子树中；

// left == null && right == null -> p q 即不在左树又不在右树；
// left ！= null && right == null -> p q 都在左树中
// left == null && right ！= null -> p q 都在右树中
// left ！= null && right ！= null -> p q 分别在左右树中 root为最近公共祖先

Node lowestCommonAncestor(Node root, Node p, Node q){
    if(root == null || root == p || root == q) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if(left == null) return right;
    if(right == null) return left;
    return root;
}

```

## 4 验证二叉搜索树
https://leetcode.cn/problems/validate-binary-search-tree/description/

```java
// 二叉搜索树 中序遍历 本质就是 前一个要比后一个小 ，因此主要判断当前root节点是不是比前一个大，如果是的话 那就是 不是的话 就不是。
Integer pre = null;
boolean BST(Node root){
    // 空树或者空节点 认为是 BST
    if(root==null) return true;

    // 判断左树是不是；
    boolean left = BST(root.left);

    // 判断当前节点是不是，同时要更新比较对象 pre
    if(pre!=null&&pre>=root.val) return false;
    pre = root.val;

    // 判断右树是不是；
    boolean right = BST(root.right);

    //返回整体判断
    return left && right;

}

// 因为二叉搜索树 中序 就是一个有序的数组。那么将其退化为一个数组 再进行判断
boolean BST(Node root){
    if(root == null) return true;

    Stack<Node> stack = new Stack();
    //遍历内容放回到 stack 中
    traversal(root,stack);

    Node pre = null;
    while(!stack.isEmpty()){
        Node cur = stack.pop();
        // pre 是大值。如果出现小值比他大那么是有问题的。
        if(pre!=null && pre.val<=cur.val) return false;
        pre = cur;
    }
    return true;
}

// 递归进行中序遍历
void traversal(Node root, Stack<Node> stack){
    if(root == null) return ;

    traversal(root.left,stack);
    stack(root);
    traversal(root.right,stack);
}



```

## 5 二叉搜索树中第K小的元素
https://leetcode.cn/problems/kth-smallest-element-in-a-bst/
// 对于搜索树 还是多考虑中序遍历 使之有序，然后再做操作
```java
int k;
int result;
// 全局存储 索引和结果；
public int kthSmallest(TreeNode root, int _k) {
    k = _k;
    doSearch(root)
    return result;
}

void doSearch(TreeNode root){
    //当索引为0时 认为已经找到 不需要遍历。
    if(k==0||root==null) return;

    doSearch(root.left);
    if(--k==0) {
        result = root.val;
        return;
    }
    doSearch(root.right);

}
```




## 6 二叉树的层次遍历
https://leetcode.cn/problems/binary-tree-level-order-traversal/description/

```java
void  BFS(Node tree){
    if(tree == null) return;
    Quene<Node> quene = new ArrayQuene();

    quene.add(tree);
    while(!quene.isEmpty()){
        //记录当前的个数 作为层数。
        int n = queue.size();
        for（int i=0;i<n;i++）{
            Node cur = quene.poll();
            println(cur.val);

            if(tree.left!=null) queue.add(tree.left);
            if(tree.right!=null) queue.add(tree.right);
        }
        println(“\n”);
    }

}
```

## 7 合并二叉树
https://leetcode-cn.com/problems/merge-two-binary-trees/

```java
Node merge(Node root1, Node root2){
    if(root1 == null )return root2;
    if(root2 == null) return root1;

    root1.val+=root2.val;
    root1.left = merge(root1.left,root2.left);
    root1.right = merge(root1.right,root2.right);
    return root1;
}
```

## 8 二叉树的所有路径
https://leetcode.cn/problems/binary-tree-paths/description/

```java
List<String> treePaths(Node root){
    if(root == null) return null;
    List<String> paths = new LinkList();

    doSearch(root,"",paths);

    return paths
}

void doSearch(Node root, String path, List<String> paths){
    if(root == null) return root;

    path+=root.val;
    if(root.left==null&&root.right==null) paths.add(path);
    doSearch(root.left,path+"->",paths);
    doSearch(root.right,path+"->",paths);

}


//递归解法
List<String> treePaths(Node root){
    List<String> paths = new LinkList();
    if(root==null) return paths;

    if(root.left==null&& root.right==null) {
        paths.add(root.val+"");
        return paths;
    }

    for (String path:treePaths(root.left)){
        paths.add(root.val +"->" +path);
    }
    for (String path:treePaths(root.right)){
        paths.add(root.val +"->" +path);
    }
    return paths;
}
```


## 9 求根到叶子节点数字之和
https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/
```java
//思路同上 不过不在是字符串 而是int
int sums(Node root){
    if(root == null) return 0;
    List<Integer> nums = new LinkedList();

    doTraversal(root,0,nums);

    int sum = 0;
    nums.forEach((num)->{
        sum+=num;
    })
    return sum;
}

void doTraversal(Node root,int num, List<Integer> nums){
    if(root == null) return;
    num = num*10+root.val;
    if(root.left == null && root.right == null) nums.add(num);
    doTraversal(root.left,num,nums);
    doTraversal(root.right,num,nums);
}
```


## 10 二叉树的最大深度
https://leetcode.cn/problems/maximum-depth-of-binary-tree/

```java
int maxDepth(Node node){
    if(node == null) return 0;
    Deque<Node> deque = new ArrayDeque();

    deque.add(node);
    int depth = 0;
    while(!deque.isEmpty()){
        int n = deque.size();
        depth++;
        for(int i=0;i<n;i++){
            Node cur = deque.poll();

            if(cur.left!=null) deque.add(cur.left);
            if(cur.right!=null) deque.add(cur.right);
        }

    }

    return depeth;
}

```

## 11 平衡二叉树
https://leetcode.cn/problems/balanced-binary-tree/description/
```java

boolean AVL(Node tree){
    if(tree == null) return true;
    

    return  Math.abs(deepth(tree.left)-deepth(tree.right))<=1 && AVL(tree.left) && AVL(tree.right);
}

int deepth(Node tree){
    if(tree == null) return 0;

    return 1+Math.max(deepth(tree.left),deepth(tree.right));
}

```

## 12 对称二叉树
https://leetcode.cn/problems/symmetric-tree/description/

```java
boolean isSymmetric(Node root){
    if(root==null)return true;

    return dfs(root.left,root.right);
}

boolean dfs(Node left,Node right){
    if(left == null && right == null) return true;
    if(left == null || right == null) return false;
    if(left.val!=right.val) return false;
    return dfs(left.left,right.right) && dfs(lift.right,right.left);
}
```