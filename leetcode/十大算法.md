## KMP
首先理解 next 数据的概念，参考ryf的这篇文章：
https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html

对于整体流程参考：https://zq99299.github.io/dsalg-tutorial/dsalg-java-hsp/14/04.html#%E5%8C%B9%E9%85%8D%E8%A1%A8%E5%AE%9E%E7%8E%B0
其核心原理在于 用一个数组来存放，匹配串本身前缀和后缀的diff。

next 数组的实现
```java
public int[] buildKmpNext(String dest) {
    int[] next = new int[dest.length()];
    // 第一个字符的前缀和后缀都没有，所以不会有公共元素，因此必定为 0
    next[0] = 0;
    // 这个i就是数组的索引，j即是数组索引，也是值，原因在于如果是升高的状态时，不会是突变的 肯定是 0-》1，但是在下降的时候 有可能是突变的，3-》0。
    for (int i = 1, j = 0; i < dest.length(); i++) {
        /*
            ABCDA
            前缀：`A、AB、ABC、ABCD`
            后缀：`BCDA、CDA、DA、A`
            公共元素 A
            部分匹配值：1
            */
        // 当  dest.charAt(i) != dest.charAt(j) 时
        // 需要从 next[j-1] 中获取新的 j
        // 这步骤是 部分匹配表的 核心点 这里是循环查找
        while (j > 0 && dest.charAt(i) != dest.charAt(j)) {
            j = next[j - 1];
        }
        // 当相等时，表示有一个部分匹配值
        if (dest.charAt(i) == dest.charAt(j)) {
            j++;
        }
        next[i] = j;
    }
    return next;
}
//源串 匹配串
private int kmpSearch(String str1, String str2, int[] next) {
    for (int i = 0, j = 0; i < str1.length(); i++) {
        while (j > 0 && str1.charAt(i) != str2.charAt(j)) {
            /*
            从源字符串中挨个的取出字符与 子串的第一个相比
            直到匹配上时：j++, 如果有一个已经匹配上了比如
                    ↓ i = 10
            BBC ABCDAB ABCDABCDABDE
                ABCDABD
                    ↑ j = 6
            然后继续下一个，这个时候由于 i 与 j 同步在增加，直到匹配到 空格与 D 时，不匹配
            此时：需要调整子串的匹配其实点：
            j = next[6 - 1] = 2, 调整后

                    ↓ i = 10
            BBC ABCDAB ABCDABCDABDE
                    ABCDABD
                    ↑ j = 2

            会发现不等于，继续调整
            j = next[2 - 1] = 0, 调整后

                    ↓ i = 10
            BBC ABCDAB ABCDABCDABDE
                        ABCDABD
                        ↑ j = 0
            此时：不满足 j > 0 了
            */
            j = next[j - 1];
        }

        /*
            从源字符串中挨个的取出字符与 子串的第一个相比
            直到匹配上时：j++, 如果有一个已经匹配上了比如
                ↓ i = 4
            BBC ABCDAB ABCDABCDABDE
                ABCDABD
                ↑ j = 0
            然后继续下一个，这个时候由于 i 与 j 同步在增加，直到匹配到 空格与 D 时，不匹配
            */
        if (str1.charAt(i) == str2.charAt(j)) {
            j++;
        }
        if (j == str2.length()) {
            return i - j + 1;
        }
    }
    return -1;
}

```